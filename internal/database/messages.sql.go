// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: messages.sql

package database

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const countOfGroupMembersWhoReadMessage = `-- name: CountOfGroupMembersWhoReadMessage :one
select count(*) from group_message_read where message_id = $1 and group_member_id = $2 and group_id = $3
`

type CountOfGroupMembersWhoReadMessageParams struct {
	MessageID     uuid.UUID
	GroupMemberID uuid.UUID
	GroupID       uuid.UUID
}

func (q *Queries) CountOfGroupMembersWhoReadMessage(ctx context.Context, arg CountOfGroupMembersWhoReadMessageParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countOfGroupMembersWhoReadMessage, arg.MessageID, arg.GroupMemberID, arg.GroupID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const countOfGroupMembersWhoReceivedMessage = `-- name: CountOfGroupMembersWhoReceivedMessage :one
select count(*) from group_message_received where message_id = $1 and group_member_id = $2 and group_id = $3
`

type CountOfGroupMembersWhoReceivedMessageParams struct {
	MessageID     uuid.UUID
	GroupMemberID uuid.UUID
	GroupID       uuid.UUID
}

func (q *Queries) CountOfGroupMembersWhoReceivedMessage(ctx context.Context, arg CountOfGroupMembersWhoReceivedMessageParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, countOfGroupMembersWhoReceivedMessage, arg.MessageID, arg.GroupMemberID, arg.GroupID)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createMessage = `-- name: CreateMessage :one
insert into messages(
    id, description, sender_id, reciever_id,
    group_id, sent, created_at, updated_at
)
values(
    gen_random_uuid(),
    $1, $2, $3, $4, $5, NOW(), NOW()
)
returning id, description, sender_id, reciever_id, group_id, sent, recieved, created_at, updated_at, read
`

type CreateMessageParams struct {
	Description string
	SenderID    uuid.UUID
	RecieverID  uuid.NullUUID
	GroupID     uuid.NullUUID
	Sent        bool
}

func (q *Queries) CreateMessage(ctx context.Context, arg CreateMessageParams) (Message, error) {
	row := q.db.QueryRowContext(ctx, createMessage,
		arg.Description,
		arg.SenderID,
		arg.RecieverID,
		arg.GroupID,
		arg.Sent,
	)
	var i Message
	err := row.Scan(
		&i.ID,
		&i.Description,
		&i.SenderID,
		&i.RecieverID,
		&i.GroupID,
		&i.Sent,
		&i.Recieved,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.Read,
	)
	return i, err
}

const getAllGroupConversations = `-- name: GetAllGroupConversations :many
select distinct messages.group_id as group_id, groups.name as group_name from messages join groups on messages.group_id = groups.id where messages.sender_id = $1
`

type GetAllGroupConversationsRow struct {
	GroupID   uuid.NullUUID
	GroupName string
}

func (q *Queries) GetAllGroupConversations(ctx context.Context, senderID uuid.UUID) ([]GetAllGroupConversationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllGroupConversations, senderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllGroupConversationsRow
	for rows.Next() {
		var i GetAllGroupConversationsRow
		if err := rows.Scan(&i.GroupID, &i.GroupName); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllGroupMessages = `-- name: GetAllGroupMessages :many
select id, description, sender_id, reciever_id, group_id, sent, recieved, created_at, updated_at, read from messages where group_id = $1 and created_at < $2 order by created_at limit 10
`

type GetAllGroupMessagesParams struct {
	GroupID   uuid.NullUUID
	CreatedAt time.Time
}

func (q *Queries) GetAllGroupMessages(ctx context.Context, arg GetAllGroupMessagesParams) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, getAllGroupMessages, arg.GroupID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.SenderID,
			&i.RecieverID,
			&i.GroupID,
			&i.Sent,
			&i.Recieved,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Read,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllMessages = `-- name: GetAllMessages :many
select id, description, sender_id, reciever_id, group_id, sent, recieved, created_at, updated_at, read from messages where sender_id = $1 and reciever_id = $2 and created_at < $3 order by created_at limit 10
`

type GetAllMessagesParams struct {
	SenderID   uuid.UUID
	RecieverID uuid.NullUUID
	CreatedAt  time.Time
}

func (q *Queries) GetAllMessages(ctx context.Context, arg GetAllMessagesParams) ([]Message, error) {
	rows, err := q.db.QueryContext(ctx, getAllMessages, arg.SenderID, arg.RecieverID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Message
	for rows.Next() {
		var i Message
		if err := rows.Scan(
			&i.ID,
			&i.Description,
			&i.SenderID,
			&i.RecieverID,
			&i.GroupID,
			&i.Sent,
			&i.Recieved,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Read,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getAllOneToOneConversations = `-- name: GetAllOneToOneConversations :many
select distinct messages.reciever_id as reciever_id, users.username as username from messages join users on messages.reciever_id = users.id where messages.sender_id = $1
`

type GetAllOneToOneConversationsRow struct {
	RecieverID uuid.NullUUID
	Username   string
}

func (q *Queries) GetAllOneToOneConversations(ctx context.Context, senderID uuid.UUID) ([]GetAllOneToOneConversationsRow, error) {
	rows, err := q.db.QueryContext(ctx, getAllOneToOneConversations, senderID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetAllOneToOneConversationsRow
	for rows.Next() {
		var i GetAllOneToOneConversationsRow
		if err := rows.Scan(&i.RecieverID, &i.Username); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestGroupMessagesByGroupID = `-- name: GetLatestGroupMessagesByGroupID :many
select groups.name as group_name, messages.description as messages, count(*) as total_new_messages
from messages join groups on messages.group_id = groups.id where messages.created_at > $1 group by group_name
order by messages.created_at
`

type GetLatestGroupMessagesByGroupIDRow struct {
	GroupName        string
	Messages         string
	TotalNewMessages int64
}

func (q *Queries) GetLatestGroupMessagesByGroupID(ctx context.Context, createdAt time.Time) ([]GetLatestGroupMessagesByGroupIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getLatestGroupMessagesByGroupID, createdAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestGroupMessagesByGroupIDRow
	for rows.Next() {
		var i GetLatestGroupMessagesByGroupIDRow
		if err := rows.Scan(&i.GroupName, &i.Messages, &i.TotalNewMessages); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestMessagesByRecieverID = `-- name: GetLatestMessagesByRecieverID :many
select users.username as sender, messages.description as messages, count(*) as total_new_messages
from messages join users on messages.sender_id = users.id where messages.reciever_id = $1 and
messages.created_at > $2 group by users.username order by messages.created_at
`

type GetLatestMessagesByRecieverIDParams struct {
	RecieverID uuid.NullUUID
	CreatedAt  time.Time
}

type GetLatestMessagesByRecieverIDRow struct {
	Sender           string
	Messages         string
	TotalNewMessages int64
}

func (q *Queries) GetLatestMessagesByRecieverID(ctx context.Context, arg GetLatestMessagesByRecieverIDParams) ([]GetLatestMessagesByRecieverIDRow, error) {
	rows, err := q.db.QueryContext(ctx, getLatestMessagesByRecieverID, arg.RecieverID, arg.CreatedAt)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetLatestMessagesByRecieverIDRow
	for rows.Next() {
		var i GetLatestMessagesByRecieverIDRow
		if err := rows.Scan(&i.Sender, &i.Messages, &i.TotalNewMessages); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const markGroupMessageRead = `-- name: MarkGroupMessageRead :exec
insert into group_message_read(message_id, group_member_id, group_id, read_at)
values($1, $2, $3, NOW())
`

type MarkGroupMessageReadParams struct {
	MessageID     uuid.UUID
	GroupMemberID uuid.UUID
	GroupID       uuid.UUID
}

func (q *Queries) MarkGroupMessageRead(ctx context.Context, arg MarkGroupMessageReadParams) error {
	_, err := q.db.ExecContext(ctx, markGroupMessageRead, arg.MessageID, arg.GroupMemberID, arg.GroupID)
	return err
}

const markGroupMessageReceived = `-- name: MarkGroupMessageReceived :exec
insert into group_message_received(message_id, group_member_id, group_id, received_at)
values($1, $2, $3, NOW())
`

type MarkGroupMessageReceivedParams struct {
	MessageID     uuid.UUID
	GroupMemberID uuid.UUID
	GroupID       uuid.UUID
}

func (q *Queries) MarkGroupMessageReceived(ctx context.Context, arg MarkGroupMessageReceivedParams) error {
	_, err := q.db.ExecContext(ctx, markGroupMessageReceived, arg.MessageID, arg.GroupMemberID, arg.GroupID)
	return err
}

const markMessageRead = `-- name: MarkMessageRead :one
update messages set read = true and updated_at = NOW() where id = $1
returning updated_at
`

func (q *Queries) MarkMessageRead(ctx context.Context, id uuid.UUID) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, markMessageRead, id)
	var updated_at time.Time
	err := row.Scan(&updated_at)
	return updated_at, err
}

const markMessageReceived = `-- name: MarkMessageReceived :one
update messages set received = true and updated_at = NOW() where id = $1
returning updated_at
`

func (q *Queries) MarkMessageReceived(ctx context.Context, id uuid.UUID) (time.Time, error) {
	row := q.db.QueryRowContext(ctx, markMessageReceived, id)
	var updated_at time.Time
	err := row.Scan(&updated_at)
	return updated_at, err
}

const removeMessage = `-- name: RemoveMessage :one
delete from messages where id = $1 and sender_id = $2 and reciever_id = $3 and group_id = $4
returning sender_id, group_id
`

type RemoveMessageParams struct {
	ID         uuid.UUID
	SenderID   uuid.UUID
	RecieverID uuid.NullUUID
	GroupID    uuid.NullUUID
}

type RemoveMessageRow struct {
	SenderID uuid.UUID
	GroupID  uuid.NullUUID
}

func (q *Queries) RemoveMessage(ctx context.Context, arg RemoveMessageParams) (RemoveMessageRow, error) {
	row := q.db.QueryRowContext(ctx, removeMessage,
		arg.ID,
		arg.SenderID,
		arg.RecieverID,
		arg.GroupID,
	)
	var i RemoveMessageRow
	err := row.Scan(&i.SenderID, &i.GroupID)
	return i, err
}

const removeMessages = `-- name: RemoveMessages :exec
delete from messages where sender_id = $1 and reciever_id = $2
`

type RemoveMessagesParams struct {
	SenderID   uuid.UUID
	RecieverID uuid.NullUUID
}

func (q *Queries) RemoveMessages(ctx context.Context, arg RemoveMessagesParams) error {
	_, err := q.db.ExecContext(ctx, removeMessages, arg.SenderID, arg.RecieverID)
	return err
}

const updateMessage = `-- name: UpdateMessage :one
update messages set description = $1, updated_at = NOW() where id = $2 and sender_id = $3 and group_id = $4
returning description, sender_id, reciever_id, group_id, sent, recieved, read, created_at, updated_at
`

type UpdateMessageParams struct {
	Description string
	ID          uuid.UUID
	SenderID    uuid.UUID
	GroupID     uuid.NullUUID
}

type UpdateMessageRow struct {
	Description string
	SenderID    uuid.UUID
	RecieverID  uuid.NullUUID
	GroupID     uuid.NullUUID
	Sent        bool
	Recieved    bool
	Read        bool
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

func (q *Queries) UpdateMessage(ctx context.Context, arg UpdateMessageParams) (UpdateMessageRow, error) {
	row := q.db.QueryRowContext(ctx, updateMessage,
		arg.Description,
		arg.ID,
		arg.SenderID,
		arg.GroupID,
	)
	var i UpdateMessageRow
	err := row.Scan(
		&i.Description,
		&i.SenderID,
		&i.RecieverID,
		&i.GroupID,
		&i.Sent,
		&i.Recieved,
		&i.Read,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
